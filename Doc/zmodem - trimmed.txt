
6.  ZMODEM REQUIREMENTS

ZMODEM requires	an 8 bit transfer medium.[1] ZMODEM escapes network
control	characters to allow operation with packet switched networks.  In
general, ZMODEM	operates over any path that supports XMODEM, and over many
that don't.

To support full	streaming,[2] the transmission path should either assert
flow control or	pass full speed	transmission without loss of data.
Otherwise the ZMODEM sender must manage	the window size.

6.1  File Contents

6.1.1  Binary Files
ZMODEM places no constraints on	the information	content	of binary files,
except that the	number of bits in the file must	be a multiple of 8.



__________

 1. The	ZMODEM design allows encoded packets for less transparent media.

 2. With XOFF and XON, or out of band flow control such	as X.25	or CTS




Chapter	6	     Rev Oct-14-88  Typeset 10-14-88			10







Chapter	6		     ZMODEM Protocol				11



6.1.2  Text Files
Since ZMODEM is	used to	transfer files between different types of computer
systems, text files must meet minimum requirements if they are to be
readable on a wide variety of systems and environments.

Text lines consist of printing ASCII characters, spaces, tabs, and
backspaces.

6.1.2.1	 ASCII End of Line
The ASCII code definition allows text lines terminated by a CR/LF (015,
012) sequence, or by a NL (012)	character.  Lines logically terminated by
a lone CR (013)	are not	ASCII text.

A CR (013) without a linefeed implies overprinting, and	is not acceptable
as a logical line separator.  Overprinted lines	should print all important
characters in the last pass to allow CRT displays to display meaningful
text.  Overstruck characters may be generated by backspacing or	by
overprinting the line with CR (015) not	followed by LF.

Overstruck characters generated	with backspaces	should be sent with the
most important character last to accommodate CRT displays that cannot
overstrike.  The sending program may use the ZCNL bit to force the
receiving program to convert the received end of line to its local end of
line convention.[3]






















__________

 3. Files that have been translated in such a way as to	modify their
    length cannot be updated with the ZCRECOV Conversion Option.




Chapter	6	     Rev Oct-14-88  Typeset 10-14-88			11







Chapter	6		     ZMODEM Protocol				12



7.  ZMODEM BASICS

7.1  Packetization

ZMODEM frames differ somewhat from XMODEM blocks.  XMODEM blocks are not
used for the following reasons:

 + Block numbers are limited to	256

 + No provision	for variable length blocks

 + Line	hits corrupt protocol signals, causing failed file transfers.  In
   particular, modem errors sometimes generate false block numbers, false
   EOTs	and false ACKs.	 False ACKs are	the most troublesome as	they cause
   the sender to lose synchronization with the receiver.

   State of the	art programs such as Professional-YAM and ZCOMM	overcome
   some	of these weaknesses with clever	proprietary code, but a	stronger
   protocol is desired.

 + It is difficult to determine	the beginning and ends of XMODEM blocks
   when	line hits cause	a loss of synchronization.  This precludes rapid
   error recovery.

7.2  Link Escape Encoding

ZMODEM achieves	data transparency by extending the 8 bit character set
(256 codes) with escape	sequences based	on the ZMODEM data link	escape
character ZDLE.[1]

Link Escape coding permits variable length data	subpackets without the
overhead of a separate byte count.  It allows the beginning of frames to
be detected without special timing techniques, facilitating rapid error
recovery.

Link Escape coding does	add some overhead.  The	worst case, a file
consisting entirely of escaped characters, would incur a 50% overhead.

The ZDLE character is special.	ZDLE represents	a control sequence of some
sort.  If a ZDLE character appears in binary data, it is prefixed with
ZDLE, then sent	as ZDLEE.

The value for ZDLE is octal 030	(ASCII CAN).  This particular value was
chosen to allow	a string of 5 consecutive CAN characters to abort a ZMODEM


__________

 1. This and other constants are defined in the	zmodem.h include file.
    Please note	that constants with a leading 0	are octal constants in C.




Chapter	7	     Rev Oct-14-88  Typeset 10-14-88			12







Chapter	7		     ZMODEM Protocol				13



session, compatible with YMODEM	session	abort.

Since CAN is not used in normal	terminal operations, interactive
applications and communications	programs can monitor the data flow for
ZDLE.  The following characters	can be scanned to detect the ZRQINIT
header,	the invitation to automatically	download commands or files.

Receipt	of five	successive CAN characters will abort a ZMODEM session.
Eight CAN characters are sent.

The receiving program decodes any sequence of ZDLE followed by a byte with
bit 6 set and bit 5 reset (upper case letter, either parity) to	the
equivalent control character by	inverting bit 6.  This allows the
transmitter to escape any control character that cannot	be sent	by the
communications medium.	In addition, the receiver recognizes escapes for
0177 and 0377 should these characters need to be escaped.

ZMODEM software	escapes	ZDLE, 020, 0220, 021, 0221, 023, and 0223.  If
preceded by 0100 or 0300 (@), 015 and 0215 are also escaped to protect the
Telenet	command	escape CR-@-CR.	 The receiver ignores 021, 0221, 023, and
0223 characters	in the data stream.

The ZMODEM routines in zm.c accept an option to	escape all control
characters, to allow operation with less transparent networks.	This
option can be given to either the sending or receiving program.

7.3  Header

All ZMODEM frames begin	with a header which may	be sent	in binary or HEX
form.  ZMODEM uses a single routine to recognize binary	and hex	headers.
Either form of the header contains the same raw	information:

 + A type byte[2] [3]

 + Four	bytes of data indicating flags and/or numeric quantities depending
   on the frame	type







__________

 2. The	frame types are	cardinal numbers beginning with	0 to minimize
    state transition table memory requirements.

 3. Future extensions to ZMODEM	may use	the high order bits of the type
    byte to indicate thread selection.




Chapter	7	     Rev Oct-14-88  Typeset 10-14-88			13







Chapter	7		     ZMODEM Protocol				14



		   Figure 1.  Order of Bytes in	Header

		   TYPE:  frame	type
		   F0: Flags least significant byte
		   P0: file Position least significant
		   P3: file Position most significant

			   TYPE	 F3 F2 F1 F0
			   -------------------
			   TYPE	 P0 P1 P2 P3

7.3.1  16 Bit CRC Binary Header
A binary header	is sent	by the sending program to the receiving	program.
ZDLE encoding accommodates XON/XOFF flow control.

A binary header	begins with the	sequence ZPAD, ZDLE, ZBIN.

The frame type byte is ZDLE encoded.

The four position/flags	bytes are ZDLE encoded.

A two byte CRC of the frame type and position/flag bytes is ZDLE encoded.

0 or more binary data subpackets with 16 bit CRC will follow depending on
the frame type.

The function zsbhdr transmits a	binary header.	The function zgethdr
receives a binary or hex header.

		   Figure 2.  16 Bit CRC Binary	Header
	    * ZDLE A TYPE F3/P0	F2/P1 F1/P2 F0/P3 CRC-1	CRC-2


7.3.2  32 Bit CRC Binary Header
A "32 bit CRC" Binary header is	similar	to a Binary Header, except the
ZBIN (A) character is replaced by a ZBIN32 (C) character, and four
characters of CRC are sent.  0 or more binary data subpackets with 32 bit
CRC will follow	depending on the frame type.

The common variable Txfcs32 may	be set TRUE for	32 bit CRC iff the
receiver indicates the capability with the CANFC32 bit.	 The zgethdr,
zsdata and zrdata functions automatically adjust to the	type of	Frame
Check Sequence being used.
		   Figure 3.  32 Bit CRC Binary	Header
      *	ZDLE C TYPE F3/P0 F2/P1	F1/P2 F0/P3 CRC-1 CRC-2	CRC-3 CRC-4


7.3.3  HEX Header
The receiver sends responses in	hex headers.  The sender also uses hex
headers	when they are not followed by binary data subpackets.




Chapter	7	     Rev Oct-14-88  Typeset 10-14-88			14







Chapter	7		     ZMODEM Protocol				15



Hex encoding protects the reverse channel from random control characters.
The hex	header receiving routine ignores parity.

Use of Kermit style encoding for control and paritied characters was
considered and rejected	because	of increased possibility of interacting
with some timesharing systems' line edit functions.  Use of HEX	headers
from the receiving program allows control characters to	be used	to
interrupt the sender when errors are detected.	A HEX header may be used
in place of a binary header wherever convenient.  If a data packet follows
a HEX header, it is protected with CRC-16.

A hex header begins with the sequence ZPAD, ZPAD, ZDLE,	ZHEX.  The zgethdr
routine	synchronizes with the ZPAD-ZDLE	sequence.  The extra ZPAD
character allows the sending program to	detect an asynchronous header
(indicating an error condition)	and then call zgethdr to receive the
header.

The type byte, the four	position/flag bytes, and the 16	bit CRC	thereof
are sent in hex	using the character set	01234567890abcdef.  Upper case hex
digits are not allowed;	they false trigger XMODEM and YMODEM programs.
Since this form	of hex encoding	detects	many patterns of errors,
especially missing characters, a hex header with 32 bit	CRC has	not been
defined.

A carriage return and line feed	are sent with HEX headers.  The	receive
routine	expects	to see at least	one of these characters, two if	the first
is CR.	The CR/LF aids debugging from printouts, and helps overcome
certain	operating system related problems.

An XON character is appended to	all HEX	packets	except ZACK and	ZFIN.  The
XON releases the sender	from spurious XOFF flow	control	characters
generated by line noise, a common occurrence.  XON is not sent after ZACK
headers	to protect flow	control	in streaming situations.  XON is not sent
after a	ZFIN header to allow clean session cleanup.

0 or more data subpackets will follow depending	on the frame type.

The function zshhdr sends a hex	header.

			  Figure 4.  HEX Header

      *	* ZDLE B TYPE F3/P0 F2/P1 F1/P2	F0/P3 CRC-1 CRC-2 CR LF	XON

(TYPE, F3...F0,	CRC-1, and CRC-2 are each sent as two hex digits.)










Chapter	7	     Rev Oct-14-88  Typeset 10-14-88			15







Chapter	7		     ZMODEM Protocol				16



7.4  Binary Data Subpackets

Binary data subpackets immediately follow the associated binary	header
packet.	 A binary data packet contains 0 to 1024 bytes of data.
Recommended length values are 256 bytes	below 2400 bps,	512 at 2400 bps,
and 1024 above 4800 bps	or when	the data link is known to be relatively
error free.[4]

No padding is used with	binary data subpackets.	 The data bytes	are ZDLE
encoded	and transmitted.  A ZDLE and frameend are then sent, followed by
two or four ZDLE encoded CRC bytes.  The CRC accumulates the data bytes
and frameend.

The function zsdata sends a data subpacket.  The function zrdata receives
a data subpacket.

7.5  ASCII Encoded Data	Subpacket

The format of ASCII Encoded data subpackets is not currently specified.
These could be used for	server commands, or main transfers in 7	bit
environments.


8.  PROTOCOL TRANSACTION OVERVIEW

As with	the XMODEM recommendation, ZMODEM timing is receiver driven.  The
transmitter should not time out	at all,	except to abort	the program if no
headers	are received for an extended period of time, say one minute.[1]


8.1  Session Startup

To start a ZMODEM file transfer	session, the sending program is	called
with the names of the desired file(s) and option(s).

The sending program may	send the string	"rz\r" to invoke the receiving
program	from a possible	command	mode.  The "rz"	followed by carriage
return activates a ZMODEM receive program or command if	it were	not
already	active.

The sender may then display a message intended for human consumption, such


__________

 4. Strategies for adjusting the subpacket length for optimal results
    based on real time error rates are still evolving.	Shorter	subpackets
    speed error	detection but increase protocol	overhead slightly.

 1. Special considerations apply when sending commands.




Chapter	8	     Rev Oct-14-88  Typeset 10-14-88			16







Chapter	8		     ZMODEM Protocol				17



as a list of the files requested, etc.

Then the sender	may send a ZRQINIT header.  The	ZRQINIT	header causes a
previously started receive program to send its ZRINIT header without
delay.

In an interactive or conversational mode, the receiving	application may
monitor	the data stream	for ZDLE.  The following characters may	be scanned
for B00	indicating a ZRQINIT header, a command to download a command or
data.

The sending program awaits a command from the receiving	program	to start
file transfers.	 If a "C", "G",	or NAK is received, an XMODEM or YMODEM
file transfer is indicated, and	file transfer(s) use the YMODEM	protocol.
Note: With ZMODEM and YMODEM, the sending program provides the file name,
but not	with XMODEM.

In case	of garbled data, the sending program can repeat	the invitation to
receive	a number of times until	a session starts.

When the ZMODEM	receive	program	starts,	it immediately sends a ZRINIT
header to initiate ZMODEM file transfers, or a ZCHALLENGE header to verify
the sending program.  The receive program resends its header at	response
time (default 10 second) intervals for a suitable period of time (40
seconds	total) before falling back to YMODEM protocol.

If the receiving program receives a ZRQINIT header, it resends the ZRINIT
header.	 If the	sending	program	receives the ZCHALLENGE	header,	it places
the data in ZP0...ZP3 in an answering ZACK header.

If the receiving program receives a ZRINIT header, it is an echo
indicating that	the sending program is not operational.

Eventually the sending program correctly receives the ZRINIT header.

The sender may then send an optional ZSINIT frame to define the	receiving
program's Attn sequence, or to specify complete	control	character
escaping.[2]

If the ZSINIT header specifies ESCCTL or ESC8, a HEX header is used, and
the receiver activates the specified ESC modes before reading the
following data subpacket.

The receiver sends a ZACK header in response, containing either	the serial


__________

 2. If the receiver specifies the same or higher level of escaping, the
    ZSINIT frame need not be sent unless an Attn sequence is needed.




Chapter	8	     Rev Oct-14-88  Typeset 10-14-88			17







Chapter	8		     ZMODEM Protocol				18



number of the receiving	program, or 0.

8.2  File Transmission

The sender then	sends a	ZFILE header with ZMODEM Conversion, Management,
and Transport options[3] followed by a ZCRCW data subpacket containing the
file name, file	length,	modification date, and other information identical
to that	used by	YMODEM Batch.

The receiver examines the file name, length, and date information provided
by the sender in the context of	the specified transfer options,	the
current	state of its file system(s), and local security	requirements.  The
receiving program should ensure	the pathname and options are compatible
with its operating environment and local security requirements.

The receiver may respond with a	ZSKIP header, which makes the sender
proceed	to the next file (if any) in the batch.

       The receiver has	a file with the	same name and length, may
       respond with a ZCRC header with a byte count, which
       requires	the sender to perform a	32 bit CRC on the
       specified number	of bytes in the	file and transmit the
       complement of the CRC in	an answering ZCRC header.[4] The
       receiver	uses this information to determine whether to
       accept the file or skip it.  This sequence may be triggered
       by the ZMCRC Management Option.

A ZRPOS	header from the	receiver initiates transmission	of the file data
starting at the	offset in the file specified in	the ZRPOS header.
Normally the receiver specifies	the data transfer to begin at
offset 0 in the	file.
       The receiver may	start the transfer further down	in the
       file.  This allows a file transfer interrupted by a loss
       of carrier or system crash to be	completed on the next
       connection without requiring the	entire file to be
       retransmitted.[5] If downloading	a file from a timesharing
       system that becomes sluggish, the transfer can be
       interrupted and resumed later with no loss of data.

The sender sends a ZDATA binary	header (with file position) followed by


__________

 3. See	below, under ZFILE header type.

 4. The	crc is initialized to 0xFFFFFFFF.  A byte count	of 0 implies the
    entire file.

 5. This does not apply	to files that have been	translated.




Chapter	8	     Rev Oct-14-88  Typeset 10-14-88			18







Chapter	8		     ZMODEM Protocol				19



one or more data subpackets.

The receiver compares the file position	in the ZDATA header with the
number of characters successfully received to the file.	 If they do not
agree, a ZRPOS error response is generated to force the	sender to the
right position within the file.[6]

A data subpacket terminated by ZCRCG and CRC does not elicit a response
unless an error	is detected; more data subpacket(s) follow immediately.

       ZCRCQ data subpackets expect a ZACK response with the
       receiver's file offset if no error, otherwise a ZRPOS
       response	with the last good file	offset.	 Another data
       subpacket continues immediately.	 ZCRCQ subpackets are
       not used	if the receiver	does not indicate FDX ability
       with the	CANFDX bit.

ZCRCW data subpackets expect a response	before the next	frame is sent.
If the receiver	does not indicate overlapped I/O capability with the
CANOVIO	bit, or	sets a buffer size, the	sender uses the	ZCRCW to allow
the receiver to	write its buffer before	sending	more data.

       A zero length data frame	may be used as an idle
       subpacket to prevent the	receiver from timing out in
       case data is not	immediately available to the sender.

In the absence of fatal	error, the sender eventually encounters	end of
file.  If the end of file is encountered within	a frame, the frame is
closed with a ZCRCE data subpacket which does not elicit a response
except in case of error.

The sender sends a ZEOF	header with the	file ending offset equal to
the number of characters in the	file.  The receiver compares this
number with the	number of characters received.	If the receiver	has
received all of	the file, it closes the	file.  If the file close was
satisfactory, the receiver responds with ZRINIT.  If the receiver has
not received all the bytes of the file,	the receiver ignores the ZEOF
because	a new ZDATA is coming.	If the receiver	cannot properly	close
the file, a ZFERR header is sent.







__________

 6. If the ZMSPARS option is used, the receiver	instead	seeks to the
    position given in the ZDATA	header.




Chapter	8	     Rev Oct-14-88  Typeset 10-14-88			19







Chapter	8		     ZMODEM Protocol				20



       After all files are processed, any further protocol
       errors should not prevent the sending program from
       returning with a	success	status.


8.3  Session Cleanup

The sender closes the session with a ZFIN header.  The receiver
acknowledges this with its own ZFIN header.

When the sender	receives the acknowledging header, it sends two
characters, "OO" (Over and Out)	and exits to the operating system or
application that invoked it.  The receiver waits briefly for the "O"
characters, then exits whether they were received or not.

8.4  Session Abort Sequence

If the receiver	is receiving data in streaming mode, the Attn
sequence is executed to	interrupt data transmission before the Cancel
sequence is sent.  The Cancel sequence consists	of eight CAN
characters and ten backspace characters.  ZMODEM only requires five
Cancel characters, the other three are "insurance".

The trailing backspace characters attempt to erase the effects of the
CAN characters if they are received by a command interpreter.

       static char canistr[] = {
	24,24,24,24,24,24,24,24,8,8,8,8,8,8,8,8,8,8,0
       };

























Chapter	8	     Rev Oct-14-88  Typeset 10-14-88			20







Chapter	8		     ZMODEM Protocol				21



9.  STREAMING TECHNIQUES / ERROR RECOVERY

It is a	fact of	life that no single method of streaming	is applicable
to a majority of today's computing and telecommunications
environments.  ZMODEM provides several data streaming methods
selected according to the limitations of the sending environment,
receiving environment, and transmission	channel(s).


9.1  Full Streaming with Sampling

If the receiver	can overlap serial I/O with disk I/O, and if the
sender can sample the reverse channel for the presence of data
without	having to wait,	full streaming can be used with	no Attn
sequence required.  The	sender begins data transmission	with a ZDATA
header and continuous ZCRCG data subpackets.  When the receiver
detects	an error, it executes the Attn sequence	and then sends a
ZRPOS header with the correct position within the file.

At the end of each transmitted data subpacket, the sender checks for
the presence of	an error header	from the receiver.  To do this,	the
sender samples the reverse data	stream for the presence	of either a
ZPAD or	CAN character.[1] Flow control characters (if present) are
acted upon.

Other characters (indicating line noise) increment a counter which is
reset whenever the sender waits	for a header from the receiver.	 If
the counter overflows, the sender sends	the next data subpacket	as
ZCRCW, and waits for a response.

ZPAD indicates some sort of error header from the receiver.  A CAN
suggests the user is attempting	to "stop the bubble machine" by
keyboarding CAN	characters.  If	one of these characters	is seen, an
empty ZCRCE data subpacket is sent.  Normally, the receiver will have
sent an	ZRPOS or other error header, which will	force the sender to
resume transmission at a different address, or take other action.  In
the unlikely event the ZPAD or CAN character was spurious, the
receiver will time out and send	a ZRPOS	header.[2]

Then the receiver's response header is read and	acted upon.[3]


__________

 1. The	call to	rdchk()	in sz.c	performs this function.

 2. The	obvious	choice of ZCRCW	packet,	which would trigger an ZACK from
    the	receiver, is not used because multiple in transit frames could
    result if the channel has a	long propagation delay.

 3. The	call to	getinsync() in sz.c performs this function.



Chapter	9	     Rev Oct-14-88  Typeset 10-14-88			21







Chapter	9		     ZMODEM Protocol				22



A ZRPOS	header resets the sender's file	offset to the correct
position.  If possible,	the sender should purge	its output buffers
and/or networks	of all unprocessed output data,	to minimize the
amount of unwanted data	the receiver must discard before receiving
data starting at the correct file offset.  The next transmitted	data
frame should be	a ZCRCW	frame followed by a wait to guarantee
complete flushing of the network's memory.

If the receiver	gets a ZACK header with	an address that	disagrees
with the sender	address, it is ignored,	and the	sender waits for
another	header.	 A ZFIN, ZABORT, or TIMEOUT terminates the session; a
ZSKIP terminates the processing	of this	file.

The reverse channel is then sampled for	the presence of	another
header from the	receiver.[4] if	one is detected, the getinsync()
function is again called to read another error header.	Otherwise,
transmission resumes at	the (possibly reset) file offset with a	ZDATA
header followed	by data	subpackets.


9.1.1  Window Management
When sending data through a network, some nodes	of the network store
data while it is transferred to	the receiver.  7000 bytes and more of
transient storage have been observed.  Such a large amount of storage
causes the transmitter to "get ahead" of the reciever.	This can be
fatal with MEGAlink and	other protocols	that depend on timely
notification of	errors from the	receiver.  This	condition is not
fatal with ZMODEM, but it does slow error recovery.

To manage the window size, the sending program uses ZCRCQ data
subpackets to trigger ZACK headers from	the receiver.  The returning
ZACK headers inform the	sender of the receiver's progress.  When the
window size (current transmitter file offset - last reported receiver
file offset) exceeds a specified value,	the sender waits for a
ZACK[5]	packet with a receiver file offset that	reduces	the window
size.

Unix sz	versions beginning with	May 9 1987 control the window size
with the "-w N"	option,	where N	is the maximum window size.  Pro-YAM,
ZCOMM and DSZ versions beginning with May 9 1987 control the window
size with "zmodem pwN".	 This is compatible with previous versions of
these programs.[6]


__________

 4. If sampling	is possible.

 5. ZRPOS and other error packets are handled normally.

 6. When used with modems or networks that simultaneously assert flow



Chapter	9	     Rev Oct-14-88  Typeset 10-14-88			22







Chapter	9		     ZMODEM Protocol				23



9.2  Full Streaming with Reverse Interrupt

The above method cannot	be used	if the reverse data stream cannot be
sampled	without	entering an I/O	wait.  An alternate method is to
instruct the receiver to interrupt the sending program when an error
is detected.

The receiver can interrupt the sender with a control character,	break
signal,	or combination thereof,	as specified in	the Attn sequence.
After executing	the Attn sequence, the receiver	sends a	hex ZRPOS
header to force	the sender to resend the lost data.

When the sending program responds to this interrupt, it	reads a	HEX
header (normally ZRPOS)	from the receiver and takes the	action
described in the previous section.  The	Unix sz.c program uses a
setjmp/longjmp call to catch the interrupt generated by	the Attn
sequence.  Catching the	interrupt activates the	getinsync() function
to read	the receiver's error header and	take appropriate action.

When compiled for standard SYSTEM III/V	Unix, sz.c uses	an Attn
sequence of Ctrl-C followed by a 1 second pause	to interrupt the
sender,	then give the sender (Unix) time to prepare for	the
receiver's error header.


9.3  Full Streaming with Sliding Window

If none	of the above methods is	applicable, hope is not	yet lost.  If
the sender can buffer responses	from the receiver, the sender can use
ZCRCQ data subpackets to get ACKs from the receiver without
interrupting the transmission of data.	After a	sufficient number of
ZCRCQ data subpackets have been	sent, the sender can read one of the
headers	that should have arrived in its	receive	interrupt buffer.

A problem with this method is the possibility of wasting an excessive
amount of time responding to the receiver's error header.  It may be
possible to program the	receiver's Attn	sequence to flush the
sender's interrupt buffer before sending the ZRPOS header.







__________________________________________________________________________

    control with XON and XOFF characters and pass XON characters that
    violate flow control, the receiving	program	should have a revision
    date of May	9 or later.




Chapter	9	     Rev Oct-14-88  Typeset 10-14-88			23







Chapter	9		     ZMODEM Protocol				24



9.4  Full Streaming over Error Free Channels

File transfer protocols	predicated on the existence of an error	free
end to end communications channel have been proposed from time to
time.  Such channels have proven to be more readily available in
theory than in actuality.  The frequency of undetected errors
increases when modem scramblers	have more bits than the	error
detecting CRC.

A ZMODEM sender	assuming an error free channel with end	to end flow
control	can send the entire file in one	frame without any checking of
the reverse stream.  If	this channel is	completely transparent,	only
ZDLE need be escaped.  The resulting protocol overhead for average
long files is less than	one per	cent.[7]

9.5  Segmented Streaming

If the receiver	cannot overlap serial and disk I/O, it uses the
ZRINIT frame to	specify	a buffer length	which the sender will not
overflow.  The sending program sends a ZCRCW data subpacket and	waits
for a ZACK header before sending the next segment of the file.

If the sending program supports	reverse	data stream sampling or
interrupt, error recovery will be faster (on average) than a protocol
(such as YMODEM) that sends large blocks.

A sufficiently large receiving buffer allows throughput	to closely
approach that of full streaming.  For example, 16kb segmented
streaming adds about 3 per cent	to full	streaming ZMODEM file
transfer times when the	round trip delay is five seconds.


10.  ATTENTION SEQUENCE

The receiving program sends the	Attn sequence whenever it detects an
error and needs	to interrupt the sending program.

The default Attn string	value is empty (no Attn	sequence).  The
receiving program resets Attn to the empty default before each
transfer session.

The sender specifies the Attn sequence in its optional ZSINIT frame.
The Attn string	is terminated with a null.



__________

 7. One	in 256 for escaping ZDLE, about	two (four if 32	bit CRC	is used)
    in 1024 for	data subpacket CRC's




Chapter	10	     Rev Oct-14-88  Typeset 10-14-88			24







Chapter	10		     ZMODEM Protocol				25



Two meta-characters perform special functions:

   + \335 (octal) Send a break signal

   + \336 (octal) Pause	one second


11.  FRAME TYPES

The numeric values for the values shown	in boldface are	given in
zmodem.h.  Unused bits and unused bytes	in the header (ZP0...ZP3) are
set to 0.

11.1  ZRQINIT

Sent by	the sending program, to	trigger	the receiving program to send
its ZRINIT header.  This avoids	the aggravating	startup	delay
associated with	XMODEM and Kermit transfers.  The sending program may
repeat the receive invitation (including ZRQINIT) if a response	is
not obtained at	first.

ZF0 contains ZCOMMAND if the program is	attempting to send a command,
0 otherwise.

11.2  ZRINIT

Sent by	the receiving program.	ZF0 and	ZF1 contain the	 bitwise or
of the receiver	capability flags:
#define	CANFDX	   01	/* Rx can send and receive true	FDX */
#define	CANOVIO	   02	/* Rx can receive data during disk I/O */
#define	CANBRK	   04	/* Rx can send a break signal */
#define	CANCRY	  010	/* Receiver can	decrypt	*/
#define	CANLZW	  020	/* Receiver can	uncompress */
#define	CANFC32	  040	/* Receiver can	use 32 bit Frame Check */
#define	ESCCTL	 0100	/* Receiver expects ctl	chars to be escaped */
#define	ESC8	 0200	/* Receiver expects 8th	bit to be escaped */

ZP0 and	ZP1 contain the	size of	the receiver's buffer in bytes,	or 0
if nonstop I/O is allowed.

11.3  ZSINIT

The Sender sends flags followed	by a binary data subpacket terminated
with ZCRCW.

/* Bit Masks for ZSINIT	flags byte ZF0 */
#define	TESCCTL	0100   /* Transmitter expects ctl chars	to be escaped
*/
#define	TESC8	0200   /* Transmitter expects 8th bit to be escaped



Chapter	11	     Rev Oct-14-88  Typeset 10-14-88			25







Chapter	11		     ZMODEM Protocol				26



*/

The data subpacket contains the	null terminated	Attn sequence,
maximum	length 32 bytes	including the terminating null.

11.4  ZACK

Acknowledgment to a ZSINIT frame, ZCHALLENGE header, ZCRCQ or ZCRCW
data subpacket.	 ZP0 to	ZP3 contain file offset.  The response to
ZCHALLENGE contains the	same 32	bit number received in the ZCHALLENGE
header.

11.5  ZFILE

This frame denotes the beginning of a file transmission	attempt.
ZF0, ZF1, and ZF2 may contain options.	A value	of 0 in	each of	these
bytes implies no special treatment.  Options specified to the
receiver override options specified to the sender with the exception
of ZCBIN.  A ZCBIN from	the sender overrides any other Conversion
Option given to	the receiver except ZCRESUM.  A	ZCBIN from the
receiver overrides any other Conversion	Option sent by the sender.


11.5.1	ZF0: Conversion	Option
If the receiver	does not recognize the Conversion Option, an
application dependent default conversion may apply.

ZCBIN "Binary" transfer	- inhibit conversion unconditionally

ZCNL Convert received end of line to local end of line
     convention.  The supported	end of line conventions	are
     CR/LF (most ASCII based operating systems except Unix
     and Macintosh), and NL (Unix).  Either of these two end
     of	line conventions meet the permissible ASCII
     definitions for Carriage Return and Line Feed/New Line.
     Neither the ASCII code nor	ZMODEM ZCNL encompass lines
     separated only by carriage	returns.  Other	processing
     appropriate to ASCII text files and the local operating
     system may	also be	applied	by the receiver.[1]

ZCRECOV	Recover/Resume interrupted file	transfer.  ZCREVOV is
     also useful for updating a	remote copy of a file that
     grows without resending of	old data.  If the destination
     file exists and is	no longer than the source, append to
     the destination file and start transfer at	the offset


__________

 1. Filtering RUBOUT, NULL, Ctrl-Z, etc.




Chapter	11	     Rev Oct-14-88  Typeset 10-14-88			26







Chapter	11		     ZMODEM Protocol				27



     corresponding to the receiver's end of file.  This
     option does not apply if the source file is shorter.
     Files that	have been converted (e.g., ZCNL) or subject
     to	a single ended Transport Option	cannot have their
     transfers recovered.

11.5.2	ZF1: Management	Option
If the receiver	does not recognize the Management Option, the
file should be transferred normally.

The ZMSKNOLOC bit instructs the	receiver to bypass the
current	file if	the receiver does not have a file with the
same name.

Five bits (defined by ZMMASK) define the following set of
mutually exclusive management options.

ZMNEWL Transfer	file if	destination file absent.  Otherwise,
     transfer file overwriting destination if the source file
     is	newer or longer.

ZMCRC Compare the source and destination files.	 Transfer if
     file lengths or file polynomials differ.

ZMAPND Append source file contents to the end of the existing
     destination file (if any).

ZMCLOB Replace existing	destination file (if any).

ZMDIFF Transfer	file if	destination file absent.  Otherwise,
     transfer file overwriting destination if files have
     different lengths or dates.

ZMPROT Protect destination file	by transferring	file only if
     the destination file is absent.

ZMNEW Transfer file if destination file	absent.	 Otherwise,
     transfer file overwriting destination if the source file
     is	newer.

11.5.3	ZF2: Transport Option
If the receiver	does not implement the particular transport
option,	the file is copied without conversion for later
processing.

ZTLZW Lempel-Ziv compression.  Transmitted data	will be
     identical to that produced	by compress 4.0	operating on
     a computer	with VAX byte ordering,	using 12 bit
     encoding.





Chapter	11	     Rev Oct-14-88  Typeset 10-14-88			27







Chapter	11		     ZMODEM Protocol				28



ZTCRYPT	Encryption.  An	initial	null terminated	string
     identifies	the key.  Details to be	determined.

ZTRLE Run Length encoding, Details to be determined.

A ZCRCW	data subpacket follows with file name, file length,
modification date, and other information described in a	later
chapter.

11.5.4	ZF3: Extended Options
The Extended Options are bit encoded.

ZTSPARS	Special	processing for sparse files, or	sender managed
     selective retransmission.	Each file segment is transmitted as
     a separate	frame, where the frames	are not	necessarily
     contiguous.  The sender should end	each segment with a ZCRCW
     data subpacket and	process	the expected ZACK to insure no data
     is	lost.  ZTSPARS cannot be used with ZCNL.

11.6  ZSKIP

Sent by	the receiver in	response to ZFILE, makes the sender skip to
the next file.

11.7  ZNAK

Indicates last header was garbled.  (See also ZRPOS).

11.8  ZABORT

Sent by	receiver to terminate batch file transfers when	requested by
the user.  Sender responds with	a ZFIN sequence.[2]

11.9  ZFIN

Sent by	sending	program	to terminate a ZMODEM session.	Receiver
responds with its own ZFIN.

11.10  ZRPOS

Sent by	receiver to force file transfer	to resume at file offset
given in ZP0...ZP3.





__________

 2. Or ZCOMPL in case of server	mode.




Chapter	11	     Rev Oct-14-88  Typeset 10-14-88			28







Chapter	11		     ZMODEM Protocol				29



11.11  ZDATA

ZP0...ZP3 contain file offset.	One or more data subpackets follow.

11.12  ZEOF

Sender reports End of File.  ZP0...ZP3 contain the ending file
offset.

11.13  ZFERR

Error in reading or writing file, protocol equivalent to ZABORT.

11.14  ZCRC

Request	(receiver) and response	(sender) for file polynomial.
ZP0...ZP3 contain file polynomial.

11.15  ZCHALLENGE

Request	sender to echo a random	number in ZP0...ZP3 in a ZACK frame.
Sent by	the receiving program to the sending program to	verify that
it is connected	to an operating	program, and was not activated by
spurious data or a Trojan Horse	message.

11.16  ZCOMPL

Request	now completed.

11.17  ZCAN

This is	a pseudo frame type returned by	gethdr() in response to	a
Session	Abort sequence.

11.18  ZFREECNT

Sending	program	requests a ZACK	frame with ZP0...ZP3 containing	the
number of free bytes on	the current file system.  A value of 0
represents an indefinite amount	of free	space.

11.19  ZCOMMAND

ZCOMMAND is sent in a binary frame.  ZF0 contains 0 or ZCACK1 (see
below).

A ZCRCW	data subpacket follows,	with the ASCII text command string
terminated with	a NULL character.  If the command is intended to be
executed by the	operating system hosting the receiving program
(e.g., "shell escape"),	it must	have "!" as the	first character.
Otherwise the command is meant to be executed by the application
program	which receives the command.



Chapter	11	     Rev Oct-14-88  Typeset 10-14-88			29







Chapter	11		     ZMODEM Protocol				30



If the receiver	detects	an illegal or badly formed command, the
receiver immediately responds with a ZCOMPL header with	an error
code in	ZP0...ZP3.

If ZF0 contained ZCACK1, the receiver immediately responds with	a
ZCOMPL header with 0 status.

Otherwise, the receiver	responds with a	ZCOMPL header when the
operation is completed.	 The exit status of the	completed command is
stored in ZP0...ZP3.  A	0 exit status implies nominal completion of
the command.

If the command causes a	file to	be transmitted,	the command sender
will see a ZRQINIT frame from the other	computer attempting to send
data.

The sender examines ZF0	of the received	ZRQINIT	header to verify it
is not an echo of its own ZRQINIT header.  It is illegal for the
sending	program	to command the receiving program to send a command.

If the receiver	program	does not implement command downloading,	it
may display the	command	to the standard	error output, then return a
ZCOMPL header.



12.  SESSION TRANSACTION EXAMPLES

12.1  A	simple file transfer

A simple transaction, one file,	no errors, no CHALLENGE, overlapped
I/O:

Sender	       Receiver

"rz\r"
ZRQINIT(0)
	       ZRINIT
ZFILE
	       ZRPOS
ZDATA data ...
ZEOF
	       ZRINIT
ZFIN
	       ZFIN
OO








Chapter	12	     Rev Oct-14-88  Typeset 10-14-88			30







Chapter	12		     ZMODEM Protocol				31



12.2  Challenge	and Command Download


Sender		    Receiver

"rz\r"
ZRQINIT(ZCOMMAND)
		    ZCHALLENGE(random-number)
ZACK(same-number)
		    ZRINIT
ZCOMMAND, ZDATA
		    (Performs Command)
		    ZCOMPL
ZFIN
		    ZFIN
OO


13.  ZFILE FRAME FILE INFORMATION

ZMODEM sends the same file information with the	ZFILE frame data
that YMODEM Batch sends	in its block 0.

N.B.: The pathname (file name) field is	mandatory.

Pathname The pathname (conventionally, the file	name) is sent as a
     null terminated ASCII string.  This is the	filename format	used
     by	the handle oriented MSDOS(TM) functions	and C library fopen
     functions.	 An assembly language example follows:
			   DB	  'foo.bar',0
     No	spaces are included in the pathname.  Normally only the	file
     name stem (no directory prefix) is	transmitted unless the
     sender has	selected YAM's f option	to send	the full absolute or
     relative pathname.	 The source drive designator (A:, B:, etc.)
     usually is	not sent.

			 Filename Considerations

	+ File names should be translated to lower case	unless the
	  sending system supports upper/lower case file	names.	This
	  is a convenience for users of	systems	(such as Unix) which
	  store	filenames in upper and lower case.

	+ The receiver should accommodate file names in	lower and
	  upper	case.

	+ When transmitting files between different operating
	  systems, file	names must be acceptable to both the sender
	  and receiving	operating systems.  If not, transformations
	  should be applied to make the	file names acceptable.	If
	  the transformations are unsuccessful,	a new file name	may



Chapter	13	     Rev Oct-14-88  Typeset 10-14-88			31







Chapter	13		     ZMODEM Protocol				32



	  be invented be the receiving program.

     If	directories are	included, they are delimited by	/; i.e.,
     "subdir/foo" is acceptable, "subdir\foo" is not.

Length The file	length and each	of the succeeding fields are
     optional.[1] The length field is stored as	a decimal string
     counting the number of data bytes in the file.

     The ZMODEM	receiver uses the file length as an estimate only.
     It	may be used to display an estimate of the transmission time,
     and may be	compared with the amount of free disk space.  The
     actual length of the received file	is determined by the data
     transfer.	A file may grow	after transmission commences, and
     all the data will be sent.

Modification Date A single space separates the modification date
     from the file length.

     The mod date is optional, and the filename	and length may be
     sent without requiring the	mod date to be sent.

     The mod date is sent as an	octal number giving the	time the
     contents of the file were last changed measured in	seconds	from
     Jan 1 1970	Universal Coordinated Time (GMT).  A date of 0
     implies the modification date is unknown and should be left as
     the date the file is received.

     This standard format was chosen to	eliminate ambiguities
     arising from transfers between different time zones.


File Mode A single space separates the file mode from the
     modification date.	 The file mode is stored as an octal string.
     Unless the	file originated	from a Unix system, the	file mode is
     set to 0.	rz(1) checks the file mode for the 0x8000 bit which
     indicates a Unix type regular file.  Files	with the 0x8000	bit
     set are assumed to	have been sent from another Unix (or
     similar) system which uses	the same file conventions.  Such
     files are not translated in any way.


Serial Number A	single space separates the serial number from the
     file mode.	 The serial number of the transmitting program is
     stored as an octal	string.	 Programs which	do not have a serial


__________

 1. Fields may not be skipped.




Chapter	13	     Rev Oct-14-88  Typeset 10-14-88			32







Chapter	13		     ZMODEM Protocol				33



     number should omit	this field, or set it to 0.  The receiver's
     use of this field is optional.


Number of Files	Remaining Iff the number of files remaining is sent,
     a single space separates this field from the previous field.
     This field	is coded as a decimal number, and includes the
     current file.  This field is an estimate, and incorrect values
     must not be allowed to cause loss of data.	 The receiver's	use
     of	this field is optional.


Number of Bytes	Remaining Iff the number of bytes remaining is sent,
     a single space separates this field from the previous field.
     This field	is coded as a decimal number, and includes the
     current file.  This field is an estimate, and incorrect values
     must not be allowed to cause loss of data.	 The receiver's	use
     of	this field is optional.


File Type Iff the file type is sent, a single space separates this
     field from	the previous field.  This field	is coded as a
     decimal number.  Currently	defined	values are:

     0	  Sequential file - no special type

     1	  Other	types to be defined.
     The receiver's use	of this	field is optional.


The file information is	terminated by a	null.  If only the pathname
is sent, the pathname is terminated with two nulls.  The length	of
the file information subpacket,	including the trailing null, must
not exceed 1024	bytes; a typical length	is less	than 64	bytes.
