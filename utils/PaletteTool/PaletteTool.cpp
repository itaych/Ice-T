// Builds a table for converting Xterm indexed color to Atari color.

#include <stdio.h>
#include <string.h>
#include <vector>
#include <cstdint>
#include <cmath>
#include <limits>

// undefine this to output text verifiably identical to Python script at https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
#define OUTPUT_ATARI

struct color_t {
    uint8_t r;
    uint8_t g;
    uint8_t b;
};

uint8_t get_atari_color(const std::vector<color_t>& rgb_palette, color_t arbitrary_color);

int main() {
    color_t orig_rgbvals[256];

    // This file is generated by Altirra (View > Adjust Colors > File > Export Palette)
    FILE* fp = fopen("altirra_palette.pal", "r");
    if (!fp) {
        printf("can't open file\n");
        return -1;
    }
    int ret = fread(orig_rgbvals, sizeof(color_t), 256, fp);
    if (ret != 256) {
        printf("can't read file\n");
        return -1;
    }
    fclose(fp);

    // We don't really have all 256 colors, only 128 are available
    std::vector<color_t> rgb_palette(128);
    for (size_t i=0; i<rgb_palette.size(); i++) {
        rgb_palette[i] = orig_rgbvals[i*2];
    }

    uint8_t out_table[256];
    memset(out_table, 255, sizeof(out_table));

    // This code is a Python to C translation of https://en.wikipedia.org/wiki/ANSI_escape_code#8-bit
    int level, code;
    uint8_t r, g, b;
    for (code=0; code<16; code++) {
        if (code > 8)
            level = 255;
        else if (code == 7)
            level = 229;
        else
            level = 205;

        if (code == 8) r=127;
        else if ((code & 1) != 0) r=level;
        else if (code == 12) r=92;
        else r=0;

        if (code == 8) g=127;
        else if ((code & 2) != 0) g=level;
        else if (code == 12) g=92;
        else g=0;

        if (code == 8) b=127;
        else if (code == 4) b=238;
        else if ((code & 4) != 0) b=level;
        else b=0;

        printf("%3d: %02X %02X %02X", code, r, g, b);
        out_table[code] = get_atari_color(rgb_palette, color_t{r, g, b});
#ifdef OUTPUT_ATARI
        printf(" --> %02x (%02x %02x %02x)", out_table[code],
            rgb_palette[out_table[code]].r,
            rgb_palette[out_table[code]].g,
            rgb_palette[out_table[code]].b
        );
#endif
        printf("\n");
    }

    printf("colors 16-231 are a 6x6x6 color cube\n");
    for (size_t red=0; red<6; red++)
        for (size_t green=0; green<6; green++)
            for (size_t blue=0; blue<6; blue++) {
                code = 16 + (red * 36) + (green * 6) + blue;
                if (red != 0) r = red * 40 + 55;
                else r=0;
                if (green != 0) g = green * 40 + 55;
                else g=0;
                if (blue != 0) b = blue * 40 + 55;
                else b=0;
                printf("%3d: %02X %02X %02X", code, r, g, b);
                out_table[code] = get_atari_color(rgb_palette, color_t{r, g, b});
#ifdef OUTPUT_ATARI
                printf(" --> %02x (%02x %02x %02x)", out_table[code],
                    rgb_palette[out_table[code]].r,
                    rgb_palette[out_table[code]].g,
                    rgb_palette[out_table[code]].b
                );
#endif
                printf("\n");
            }

    printf("colors 232-255 are a grayscale ramp, intentionally leaving out black and white\n");
    code = 232;
    for (size_t gray=0; gray<24; gray++) {
        level = gray * 10 + 8;
        code = 232 + gray;
        r=g=b=level;
        printf("%3d: %02X %02X %02X", code, r, g, b);
        out_table[code] = get_atari_color(rgb_palette, color_t{r, g, b});
#ifdef OUTPUT_ATARI
        // extra tweak: get_atari_color sometimes chooses a non-gray color here
        if (out_table[code] & 0xf0) {
            out_table[code] &= 0x0f;
        }
        // also disallow black for this region
        if (out_table[code] == 0) {
            out_table[code] = 0x02;
        }

        printf(" --> %02x (%02x %02x %02x)", out_table[code],
            rgb_palette[out_table[code]].r,
            rgb_palette[out_table[code]].g,
            rgb_palette[out_table[code]].b
        );
#endif
        printf("\n");
    }

    for (size_t i=0; i<sizeof(out_table); i++) {
        if (out_table[i] == 255) {
            printf("Unset byte at %zu\n", i);
        }
    }

#ifdef OUTPUT_ATARI
    printf("\nCopy and paste into vt2.asm:\n\nxterm_index_to_atari");
    for (size_t i=0; i<sizeof(out_table); i++) {
        if (!(i % 16)) {
            printf("\n\t.byte ");
        }
        else {
            printf(", ");
        }
        printf("$%02x", out_table[i]);
    }
    printf("\n\n");
#endif
}

// Given the Atari palette and an arbitrary rgb color, finds the index of the nearest Atari color.
// This basically searches for the color with the smallest Euclidean distance (in RGB space) to
// the given color. We multiply the found index by 2 to return the true Atari color because non-GTIA
// modes only support 128 colors, set in bits 1-7 of the color register. (Thanks ChatGPT)
uint8_t get_atari_color(const std::vector<color_t>& rgb_palette, color_t arbitrary_color) {
    uint8_t closest_index = 0;
    double min_distance = std::numeric_limits<double>::max();

    for (uint8_t i = 0; i < rgb_palette.size(); ++i) {
        const color_t& palette_color = rgb_palette[i];

        // Calculate squared Euclidean distance in RGB space
        int dr = static_cast<int>(palette_color.r) - arbitrary_color.r;
        int dg = static_cast<int>(palette_color.g) - arbitrary_color.g;
        int db = static_cast<int>(palette_color.b) - arbitrary_color.b;
        double distance = dr * dr + dg * dg + db * db;

        if (distance < min_distance) {
            min_distance = distance;
            closest_index = i;
        }
    }

    return closest_index << 1; // shift to get actual Atari color
}
